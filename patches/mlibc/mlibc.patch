diff --git a/mlibc-workdir/abis/echidnaos/auxv.h b/mlibc-workdir/abis/echidnaos/auxv.h
new file mode 100644
index 0000000..6f17767
--- /dev/null
+++ b/mlibc-workdir/abis/echidnaos/auxv.h
@@ -0,0 +1,10 @@
+#ifndef _ABIBITS_AUXV_H
+#define _ABIBITS_AUXV_H
+
+#define AT_ENTRY 10
+#define AT_PHDR 20
+#define AT_PHENT 21
+#define AT_PHNUM 22
+#define AT_EXECFN 31
+
+#endif // _ABIBITS_AUXV_H
diff --git a/mlibc-workdir/abis/echidnaos/seek-whence.h b/mlibc-workdir/abis/echidnaos/seek-whence.h
new file mode 100644
index 0000000..901121c
--- /dev/null
+++ b/mlibc-workdir/abis/echidnaos/seek-whence.h
@@ -0,0 +1,8 @@
+#ifndef _ABIBITS_SEEK_WHENCE_H
+#define _ABIBITS_SEEK_WHENCE_H
+
+#define SEEK_CUR 2
+#define SEEK_END 1
+#define SEEK_SET 0
+
+#endif // _ABIBITS_SEEK_WHENCE_H
diff --git a/mlibc-orig/meson.build b/mlibc-workdir/meson.build
index 3818563..7c788af 100644
--- a/mlibc-orig/meson.build
+++ b/mlibc-workdir/meson.build
@@ -8,7 +8,7 @@ rtdl_include_dirs = [
 ]
 libc_include_dirs = [
 	include_directories('options/internal/include'),
-	include_directories('options/internal/x86_64-include'),
+	include_directories('options/internal/' + host_machine.cpu_family() + '-include'),
 	include_directories('options/elf/include'),
 	include_directories('options/lsb/include'),
 	include_directories('options/glibc/include'),
@@ -89,6 +89,11 @@ elif host_machine.system() == 'qword'
 	rtdl_include_dirs += include_directories('sysdeps/qword/include')
 	libc_include_dirs += include_directories('sysdeps/qword/include')
 	subdir('sysdeps/qword')
+elif host_machine.system() == 'echidnaos'
+	disable_linux_option = true
+	rtdl_include_dirs += include_directories('sysdeps/echidnaos/include')
+	libc_include_dirs += include_directories('sysdeps/echidnaos/include')
+	subdir('sysdeps/echidnaos')
 elif host_machine.system() == 'sigma'
 	#disable_linux_option = true
 	rtdl_include_dirs += include_directories('sysdeps/sigma/include')
@@ -146,8 +151,8 @@ internal_sources = [
 	'options/internal/gcc/guard-abi.cpp',
 	'options/internal/gcc/initfini.cpp',
 	'options/internal/gcc-extra/cxxabi.cpp',
-	'options/internal/x86_64/setjmp.S',
-	'options/internal/x86_64/thread.cpp',
+	'options/internal' / host_machine.cpu_family() / 'setjmp.S',
+	'options/internal' / host_machine.cpu_family() / 'thread.cpp',
 ]
 
 if not static
@@ -186,11 +191,11 @@ rtdl_sources += [
 	'options/internal/generic/frigg.cpp',
 	'options/rtdl/generic/main.cpp',
 	'options/rtdl/generic/linker.cpp',
-	'options/rtdl/x86_64/runtime.S',
+	'options/rtdl' / host_machine.cpu_family() / 'runtime.S',
 ]
 
 if not static
-	rtdl_sources += 'options/rtdl/x86_64/entry.S'
+	rtdl_sources += 'options/rtdl' / host_machine.cpu_family() / 'entry.S'
 endif
 
 subdir('options/elf')
@@ -229,12 +234,6 @@ if not headers_only
 		shared_library('util', 'libutil/src/dummy.cpp', install: true)
 		shared_library('m', 'libm/src/dummy.cpp', install: true)
 	else
-		ldso_lib = static_library('ld', rtdl_sources,
-				name_prefix: '',
-				cpp_args: ['-fvisibility=hidden', '-DMLIBC_BUILDING_RTDL', '-DFRIGG_HAVE_LIBC'],
-				include_directories: rtdl_include_dirs,
-				dependencies: rtdl_deps,
-				install: false)
 		libc = static_library('c',
 				[
 					libc_sources,
@@ -242,17 +241,17 @@ if not headers_only
 					ansi_sources,
                                         lsb_sources,
 				],
+				pic: false,
 				cpp_args: ['-DFRIGG_HAVE_LIBC'],
 				include_directories: libc_include_dirs,
 				dependencies: libc_deps,
-				link_with: [ldso_lib],
-				link_whole: [libc_sublibs, ldso_lib],
+				link_whole: libc_sublibs,
 				install: true)
 
-		static_library('pthread', 'libpthread/src/dummy.cpp', install: true)
-		static_library('rt', 'librt/src/dummy.cpp', install: true)
-		static_library('util', 'libutil/src/dummy.cpp', install: true)
-		static_library('m', 'libm/src/dummy.cpp', install: true)
+		static_library('pthread', 'libpthread/src/dummy.cpp', pic: false, install: true)
+		static_library('rt', 'librt/src/dummy.cpp', pic: false, install: true)
+		static_library('util', 'libutil/src/dummy.cpp', pic: false, install: true)
+		static_library('m', 'libm/src/dummy.cpp', pic: false, install: true)
 	endif
 endif
 
diff --git a/mlibc-orig/options/ansi/generic/stdlib-stubs.cpp b/mlibc-workdir/options/ansi/generic/stdlib-stubs.cpp
index cde5af7..3c5063b 100644
--- a/mlibc-orig/options/ansi/generic/stdlib-stubs.cpp
+++ b/mlibc-workdir/options/ansi/generic/stdlib-stubs.cpp
@@ -99,7 +99,7 @@ long strtol(const char *__restrict string, char **__restrict end, int base) {
 	return negative ? -result : result;
 }
 long long strtoll(const char *__restrict string, char **__restrict end, int base) {
-	static_assert(sizeof(long long) == sizeof(long));
+	//static_assert(sizeof(long long) == sizeof(long));
 	return strtol(string, end, base);
 }
 // this function is copied from newlib and available under a BSD license
@@ -154,7 +154,7 @@ unsigned long strtoul(const char *__restrict nptr, char **__restrict endptr, int
 	return (acc);
 }
 unsigned long long strtoull(const char *__restrict string, char **__restrict end, int base) {
-	static_assert(sizeof(unsigned long long) == sizeof(unsigned long));
+	//static_assert(sizeof(unsigned long long) == sizeof(unsigned long));
 	return strtoul(string, end, base);
 }
 
diff --git a/mlibc-orig/options/elf/generic/startup.cpp b/mlibc-workdir/options/elf/generic/startup.cpp
index 73cc50e..9265090 100644
--- a/mlibc-orig/options/elf/generic/startup.cpp
+++ b/mlibc-workdir/options/elf/generic/startup.cpp
@@ -6,6 +6,7 @@
 #include <bits/ensure.h>
 #include <mlibc/elf/startup.h>
 #include <mlibc/environment.hpp>
+#include <mlibc/debug.hpp>
 
 extern "C" size_t __init_array_start[];
 extern "C" size_t __init_array_end[];
@@ -21,7 +22,6 @@ struct global_constructor_guard {
 static global_constructor_guard g;
 
 void __mlibc_run_constructors() {
-/*
     if (!constructors_ran_already) {
         size_t constructor_count = (size_t)__init_array_end - (size_t)__init_array_start;
         constructor_count /= sizeof(void*);
@@ -30,7 +30,6 @@ void __mlibc_run_constructors() {
             ptr();
         }
     }
-*/
 }
 
 namespace mlibc {
diff --git a/mlibc-orig/options/internal/gcc-extra/mlibc_crtbegin.S b/mlibc-workdir/options/internal/gcc-extra/mlibc_crtbegin.S
index 77b143b..f3990b9 100644
--- a/mlibc-orig/options/internal/gcc-extra/mlibc_crtbegin.S
+++ b/mlibc-workdir/options/internal/gcc-extra/mlibc_crtbegin.S
@@ -3,7 +3,7 @@
 .hidden __dso_handle
 .global __dso_handle
 __dso_handle:
-	.quad __dso_handle
+	.long __dso_handle
 
 .section .init
 .hidden _init
diff --git a/mlibc-workdir/options/internal/x86/thread.cpp b/mlibc-workdir/options/internal/x86/thread.cpp
new file mode 100644
index 0000000..671e77e
--- /dev/null
+++ b/mlibc-workdir/options/internal/x86/thread.cpp
@@ -0,0 +1,13 @@
+#include <mlibc/thread.hpp>
+
+#include <stdint.h>
+
+namespace mlibc {
+
+Tcb *get_current_tcb() {
+	uintptr_t ptr;
+	asm ("movl %%gs:0, %0" : "=r"(ptr));
+	return reinterpret_cast<Tcb *>(ptr);
+}
+
+} // namespace mlibc
diff --git a/mlibc-workdir/options/internal/x86-include/mlibc/arch-defs.hpp b/mlibc-workdir/options/internal/x86-include/mlibc/arch-defs.hpp
new file mode 100644
index 0000000..0a4789f
--- /dev/null
+++ b/mlibc-workdir/options/internal/x86-include/mlibc/arch-defs.hpp
@@ -0,0 +1,12 @@
+#ifndef MLIBC_ARCH_DEFS_HPP
+#define MLIBC_ARCH_DEFS_HPP
+
+#include <stddef.h>
+
+namespace mlibc {
+
+inline constexpr size_t page_size = 0x1000;
+
+} // namespace mlibc
+
+#endif // MLIBC_ARCH_DEFS_HPP
diff --git a/mlibc-orig/options/rtdl/generic/main.cpp b/mlibc-workdir/options/rtdl/generic/main.cpp
index c18beeb..bd3fe2c 100644
--- a/mlibc-orig/options/rtdl/generic/main.cpp
+++ b/mlibc-workdir/options/rtdl/generic/main.cpp
@@ -267,7 +267,7 @@ struct __abi_tls_entry {
 	uint64_t offset;
 };
 
-static_assert(sizeof(__abi_tls_entry) == 16, "Bad __abi_tls_entry size");
+//static_assert(sizeof(__abi_tls_entry) == 16, "Bad __abi_tls_entry size");
 
 const char *lastError;
 
diff --git a/mlibc-workdir/options/rtdl/x86/entry.S b/mlibc-workdir/options/rtdl/x86/entry.S
new file mode 100644
index 0000000..c4e3392
--- /dev/null
+++ b/mlibc-workdir/options/rtdl/x86/entry.S
@@ -0,0 +1,10 @@
+
+.global _start
+_start:
+	call relocateSelf
+
+	mov %esp, %eax
+    push %eax
+	call interpreterMain
+
+	jmp *%rax
diff --git a/mlibc-workdir/options/rtdl/x86/runtime.S b/mlibc-workdir/options/rtdl/x86/runtime.S
new file mode 100644
index 0000000..c233646
--- /dev/null
+++ b/mlibc-workdir/options/rtdl/x86/runtime.S
@@ -0,0 +1,4 @@
+
+.global pltRelocateStub
+pltRelocateStub:
+	# TODO: implement this lol
diff --git a/mlibc-workdir/sysdeps/echidnaos/crt-i386/crt0.S b/mlibc-workdir/sysdeps/echidnaos/crt-i386/crt0.S
new file mode 100644
index 0000000..3aad212
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/crt-i386/crt0.S
@@ -0,0 +1,11 @@
+.section .echidnaos_entry
+.global _start
+_start:
+    push $main
+    call __mlibc_entry
+
+.section .text
+.global ___tls_get_addr
+___tls_get_addr:
+    mov $0x12348765, %eax
+    jmp ___tls_get_addr
diff --git a/mlibc-workdir/sysdeps/echidnaos/generic/entry.cpp b/mlibc-workdir/sysdeps/echidnaos/generic/entry.cpp
new file mode 100644
index 0000000..282953f
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/generic/entry.cpp
@@ -0,0 +1,20 @@
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <bits/ensure.h>
+#include <mlibc/elf/startup.h>
+
+#include <mlibc/all-sysdeps.hpp>
+
+extern char **environ;
+
+extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[])) {
+    int argc = *((int *)0x1000);
+    char **argv = (char **)0x1010;
+
+    __mlibc_run_constructors();
+
+	auto result = main_fn(argc, argv, environ);
+	exit(result);
+}
+
diff --git a/mlibc-workdir/sysdeps/echidnaos/generic/generic.cpp b/mlibc-workdir/sysdeps/echidnaos/generic/generic.cpp
new file mode 100644
index 0000000..ebb8f66
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/generic/generic.cpp
@@ -0,0 +1,215 @@
+
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+
+#define STUB_ONLY { __ensure(!"STUB_ONLY function was called"); __builtin_unreachable(); }
+
+namespace mlibc {
+    // The basics
+    void sys_libc_log(const char *message) {
+        int discard;
+        asm volatile (
+            "int $0x80"
+            : "=a"(discard)
+            : "a"(4), "c"(message)
+            : "edx", "memory"
+        );
+    }
+    void sys_libc_panic() {
+        sys_libc_log("\nmlibc: panic.\n");
+        for (;;);
+    }
+
+    int sys_getcwd(char *buffer, size_t size) {
+        int discard;
+        asm volatile (
+            "int $0x80"
+            : "=a"(discard)
+            : "a"(0x1a), "c"(buffer)
+            : "edx", "memory"
+        );
+        return 0;
+    }
+
+    // Memory Related Functions
+    int sys_anon_free(void *pointer, size_t size) {
+        mlibc::infoLogger() << "mlibc: in sys_anon_free"<< frg::endlog;
+        return -1;
+    }
+
+    int sys_anon_allocate(size_t size, void **pointer) {
+        int discard;
+        size_t heap_base;
+        size_t heap_size;
+        asm volatile (
+            "mov $0x10, %%eax;"
+            "int $0x80;"
+            "mov %%eax, %%ebx;"
+            "mov $0x11, %%eax;"
+            "int $0x80;"
+            : "=b" (heap_base), "=a" (heap_size)
+            :
+            : "edx", "memory"
+        );
+        size_t ptr = heap_base + heap_size;
+        asm volatile (
+            "int $0x80"
+            : "=a"(discard)
+            : "a"(0x12), "c"(heap_size + size)
+            : "edx", "memory"
+        );
+    	*pointer = (void*)ptr;
+        return 0;
+    }
+
+    // TODO: Actually implement this
+    int sys_futex_wait(int *pointer, int expected) STUB_ONLY
+    int sys_futex_wake(int *pointer) STUB_ONLY
+
+    // Task functions
+    void sys_exit(int status) {
+        int discard;
+
+        asm volatile ("int $0x80"
+                : "=a"(discard)
+                : "a"(0x00), "c"(status)
+                : "edx", "memory"
+        );
+    }
+
+    int sys_tcb_set(void *pointer) STUB_ONLY
+
+    // File functions
+    int sys_open(const char *path, int flags, int *fd) {
+        int discard;
+        int ret;
+
+        asm volatile ("int $0x80"
+                : "=a"(ret), "=d"(discard)
+                : "a"(0x2a), "c"(path), "d"(flags), "D"(0)
+                : "memory"
+        );
+
+        *fd = ret;
+
+        return 0;
+    }
+
+    int sys_close(int fd) {
+        int ret;
+
+        asm volatile ("int $0x80"
+                : "=a"(ret)
+                : "a"(0x2b), "c"(fd)
+                : "edx", "memory"
+        );
+
+        return ret;
+    }
+
+    int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+        int discard;
+        off_t ret;
+
+        asm volatile ("int $0x80"
+                : "=a"(ret), "=d"(discard)
+                : "a"(0x2e), "c"(fd), "d"(offset), "D"(whence)
+                : "memory"
+        );
+
+        *new_offset = ret;
+
+        return 0;
+    }
+
+    int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
+        int discard;
+        asm volatile ("int $0x80"
+                : "=a"(count), "=d"(discard)
+                : "a"(0x2c), "c"(fd), "d"(buf), "D"(count)
+                : "memory"
+        );
+
+        *bytes_read = count;
+        return 0;
+    }
+
+    int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
+        int discard;
+        asm volatile ("int $0x80"
+                : "=a"(count), "=d"(discard)
+                : "a"(0x2d), "c"(fd), "d"(buf), "D"(count)
+                : "memory"
+        );
+
+        *bytes_written = count;
+        return 0;
+    }
+
+    int sys_isatty(int fd) {
+        return 0;
+    }
+
+    int sys_ttyname(int fd, char *buf, size_t size) {
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+        return ENOSYS;
+    }
+
+    int sys_gethostname(char *buffer, size_t bufsize) {
+        strncpy(buffer, "echidnaOS", bufsize-1);
+        buffer[bufsize-1] = 0;
+        return 0;
+    }
+
+    gid_t sys_getgid() {
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+        return 0;
+    }
+    gid_t sys_getegid() {
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+        return 0;
+    }
+    uid_t sys_getuid() {
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+        return 0;
+    }
+    uid_t sys_geteuid() {
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+        return 0;
+    }
+    pid_t sys_getpid() {
+        pid_t pid;
+        asm volatile ("int $0x80"
+                : "=a"(pid)
+                : "a"(0x15)
+                : "edx", "memory");
+        return pid;
+    }
+    pid_t sys_getppid() {
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+        return 0;
+    }
+
+    int sys_clock_get(int clock, time_t *secs, long *nanos) {
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+        *secs  = 0;
+        *nanos = 0;
+        return 0;
+    }
+
+    int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+
+        return ENOSYS;
+    }
+
+    int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) {
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+        return ENOSYS;
+    }
+} // namespace mlibc
+
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/abi.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/abi.h
new file mode 120000
index 0000000..c945860
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/abi.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/abi.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/auxv.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/auxv.h
new file mode 120000
index 0000000..0e298c4
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/echidnaos/auxv.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/blkcnt_t.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/blkcnt_t.h
new file mode 120000
index 0000000..e9d9f1b
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/blkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/blkcnt_t.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/blksize_t.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/blksize_t.h
new file mode 120000
index 0000000..c6dfb6e
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/blksize_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/blksize_t.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/dev_t.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/dev_t.h
new file mode 120000
index 0000000..0c1143b
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/dev_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/dev_t.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/errno.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/errno.h
new file mode 120000
index 0000000..589859f
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/errno.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/errno.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/fcntl.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/fcntl.h
new file mode 120000
index 0000000..ea5323a
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/fcntl.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/fcntl.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/gid_t.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/gid_t.h
new file mode 120000
index 0000000..6a77218
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/gid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/gid_t.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/in.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/in.h
new file mode 120000
index 0000000..b58c683
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/in.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/in.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/ino_t.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/ino_t.h
new file mode 120000
index 0000000..10d644e
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/ino_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/ino_t.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/mode_t.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/mode_t.h
new file mode 120000
index 0000000..29d7733
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/mode_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/mode_t.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/nlink_t.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/nlink_t.h
new file mode 120000
index 0000000..7618c27
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/nlink_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/nlink_t.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/pid_t.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/pid_t.h
new file mode 120000
index 0000000..3fd26a7
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/pid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/pid_t.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/resource.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/resource.h
new file mode 120000
index 0000000..3e59c75
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/resource.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/resource.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/seek-whence.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/seek-whence.h
new file mode 120000
index 0000000..fcf5063
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/echidnaos/seek-whence.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/signal.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/signal.h
new file mode 120000
index 0000000..b20e511
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/signal.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/signal.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/socket.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/socket.h
new file mode 120000
index 0000000..0e1d6be
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/socket.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/socket.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/stat.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/stat.h
new file mode 120000
index 0000000..82642c3
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/stat.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/stat.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/termios.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/termios.h
new file mode 120000
index 0000000..cfcfe76
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/termios.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/termios.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/time.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/time.h
new file mode 120000
index 0000000..97f3d52
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/time.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/time.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/uid_t.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/uid_t.h
new file mode 120000
index 0000000..1113eba
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/uid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/uid_t.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/vm-flags.h b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/vm-flags.h
new file mode 120000
index 0000000..f1a985e
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/vm-flags.h
\ No newline at end of file
diff --git a/mlibc-workdir/sysdeps/echidnaos/include/sys_api.h b/mlibc-workdir/sysdeps/echidnaos/include/sys_api.h
new file mode 100644
index 0000000..af0a346
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/include/sys_api.h
@@ -0,0 +1,425 @@
+/*
+ *  echidnaOS kernel API
+ */
+
+#ifndef __SYS_API_H__
+#define __SYS_API_H__
+
+#include <stdint.h>
+
+typedef struct {
+    char filename[2048];
+    int filetype;
+    uint64_t size;
+} vfs_metadata_t;
+
+typedef struct {
+    char* path;
+    char* ti_stdin;
+    char* ti_stdout;
+    char* ti_stderr;
+    char* pwd;
+    char* name;
+    char* server_name;
+    int argc;
+    char** argv;
+} task_info_t;
+
+#define VFS_FILE_TYPE 0
+#define VFS_DIRECTORY_TYPE 1
+#define VFS_DEVICE_TYPE 2
+#define VFS_SUCCESS 0
+#define VFS_FAILURE -2
+
+#define ECH_O_RDONLY        0b0001
+#define ECH_O_WRONLY        0b0010
+#define ECH_O_RDWR          0b0100
+
+#define ECH_O_APPEND        0b001000
+#define ECH_O_CREAT         0b010000
+#define ECH_O_TRUNC         0b100000
+
+#define ECH_SEEK_SET 0
+#define ECH_SEEK_END 1
+#define ECH_SEEK_CUR 2
+
+#define OS_open(path, flags, mode) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2a, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (path),  \
+                       "d" (flags), \
+                       "D" (mode) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_close(handle) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2b, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (handle) \
+                     : "edx" );         \
+    return_val;                                \
+})
+
+#define OS_read(handle, buf, len) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2c, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (handle),  \
+                       "d" (buf), \
+                       "D" (len) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_write(handle, buf, len) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2d, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (handle),  \
+                       "d" (buf), \
+                       "D" (len) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_lseek(a, b, c) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2e, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (a),  \
+                       "d" (b), \
+                       "D" (c) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_signal(sig, handler) ({ \
+    int ret; \
+    asm volatile (  "movl $0x16, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret)                 \
+                     : "c" (sig),        \
+                       "d" (handler)    \
+                     :  );         \
+    ret; \
+})
+
+#define OS_getpid() ({              \
+    uint32_t val;                         \
+    asm volatile (  "movl $0x15, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (val)      \
+                     : \
+                     : "edx" );         \
+    val;                               \
+})
+
+#define OS_get_heap_base() ({              \
+    uint32_t val;                         \
+    asm volatile (  "movl $0x10, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (val)      \
+                     : \
+                     : "edx" );         \
+    val;                               \
+})
+
+#define OS_get_heap_size() ({              \
+    uint32_t val;                         \
+    asm volatile (  "movl $0x11, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (val)      \
+                     : \
+                     : "edx" );         \
+    val;                               \
+})
+
+#define OS_resize_heap(val) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x12, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)      \
+                     : "c" (val)  \
+                     : "edx" );         \
+    return_val;                                \
+})
+
+#define OS_pwd(value) ({                \
+    asm volatile (  "movl $0x1a, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     : "c" (value)      \
+                     : "eax", "edx" );  \
+})
+
+#define OS_what_stdin(value) ({                \
+    asm volatile (  "movl $0x1b, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     : "c" (value)      \
+                     : "eax", "edx" );  \
+})
+
+#define OS_what_stdout(value) ({                \
+    asm volatile (  "movl $0x1c, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     : "c" (value)      \
+                     : "eax", "edx" );  \
+})
+
+#define OS_what_stderr(value) ({                \
+    asm volatile (  "movl $0x1d, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     : "c" (value)      \
+                     : "eax", "edx" );  \
+})
+
+#define OS_ipc_send_packet(pid, payload, len) ({ \
+    asm volatile (  "movl $0x08, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     : "c" (pid),        \
+                       "d" (payload),    \
+                       "D" (len)      \
+                     : "eax" );         \
+})
+
+#define OS_ipc_read_packet(payload) ({  \
+    uint32_t pid;                            \
+    asm volatile (  "movl $0x09, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (pid)         \
+                     : "c" (payload)    \
+                     : "edx" );         \
+    pid;                                \
+})
+
+#define OS_ipc_resolve_name(server_name) ({  \
+    uint32_t pid;                            \
+    asm volatile (  "movl $0x0a, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (pid)         \
+                     : "c" (server_name)  \
+                     : "edx" );         \
+    pid;                                \
+})
+
+#define OS_ipc_payload_sender() ({      \
+    uint32_t pid;                              \
+    asm volatile (  "movl $0x0b, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (pid)         \
+                     :                  \
+                     : "edx" );         \
+    pid;                                  \
+})
+
+#define OS_ipc_payload_length() ({      \
+    uint32_t pid;                              \
+    asm volatile (  "movl $0x0c, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (pid)         \
+                     :                  \
+                     : "edx" );         \
+    pid;                                  \
+})
+
+#define OS_ipc_await() ({                \
+    asm volatile (  "movl $0x0d, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     :                    \
+                     :  );  \
+})
+
+#define OS_vfs_list(path, metadata, entry) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x32, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (path),  \
+                       "d" (metadata), \
+                       "D" (entry) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_vfs_get_metadata(path, metadata, type) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x33, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (path),  \
+                       "d" (metadata), \
+                       "D" (type) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_vfs_read(path, loc) ({  \
+    int return_val;                            \
+    uint32_t loc_low = loc & 0x00000000ffffffff; \
+    uint32_t loc_high = loc / 0x100000000; \
+    asm volatile (  "movl $0x30, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (path),  \
+                       "d" (loc_low), \
+                       "D" (loc_high) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_vfs_write(path, loc, val) ({  \
+    int return_val;                            \
+    uint32_t loc_low = loc & 0x00000000ffffffff; \
+    uint32_t loc_high = loc / 0x100000000; \
+    asm volatile (  "movl $0x31, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (path),  \
+                       "d" (loc_low), \
+                       "D" (loc_high), \
+                       "S" (val) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_vfs_mkdir(path, perms) ({ \
+    int ret; \
+    asm volatile (  "movl $0x35, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret)                 \
+                     : "c" (path),        \
+                       "d" (perms)    \
+                     :  );         \
+    ret; \
+})
+
+#define OS_vfs_create(path, perms) ({ \
+    int ret; \
+    asm volatile (  "movl $0x36, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret)                 \
+                     : "c" (path),        \
+                       "d" (perms)    \
+                     :  );         \
+    ret; \
+})
+
+#define OS_vfs_cd(path) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2f, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)      \
+                     : "c" (path)  \
+                     : "edx" );         \
+    return_val;                                \
+})
+
+#define OS_vfs_remove(path) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x34, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)      \
+                     : "c" (path)  \
+                     : "edx" );         \
+    return_val;                                \
+})
+
+#define OS_vdev_in_ready(value) ({               \
+    int ret; \
+    asm volatile (  "movl $0x21, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret) \
+                     : "c" (value)      \
+                     : "edx" );  \
+    ret; \
+})
+
+#define OS_vdev_out_ready(value) ({               \
+    int ret; \
+    asm volatile (  "movl $0x22, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret) \
+                     : "c" (value)      \
+                     : "edx" );  \
+    ret; \
+})
+
+#define OS_vdev_register(in, fin, out, fout) ({ \
+    int ret; \
+    asm volatile (  "movl $0x20, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret)                 \
+                     : "c" (in),        \
+                       "d" (fin),    \
+                       "D" (out), \
+                       "S" (fout) \
+                     :  );         \
+    ret; \
+})
+
+#define OS_vdev_await() ({                \
+    int ret; \
+    asm volatile (  "movl $0x23, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret)                 \
+                     :                    \
+                     : "edx" );  \
+    ret; \
+})
+
+#define OS_general_execute(value) ({               \
+    int ret; \
+    asm volatile (  "movl $0x01, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret) \
+                     : "c" (value)      \
+                     : "edx" );  \
+    ret; \
+})
+
+#define OS_general_execute_block(value) ({               \
+    uint32_t ret_low; \
+    uint32_t ret_hi; \
+    uint64_t ret; \
+    asm volatile (  "movl $0x02, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret_low),                 \
+                       "=d" (ret_hi) \
+                     : "c" (value)      \
+                     :  );  \
+    ret = ((uint64_t)(ret_hi) << 32) + (uint64_t)ret_low; \
+    ret; \
+})
+
+#define OS_exit(value) ({               \
+    asm volatile (  "movl $0x00, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : \
+                     : "c" (value)      \
+                     : "eax", "edx" );  \
+})
+
+#define OS_fork() ({               \
+    int ret; \
+    asm volatile (  "movl $0x05, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret) \
+                     :     \
+                     : "edx" );  \
+    ret; \
+})
+
+#endif
diff --git a/mlibc-workdir/sysdeps/echidnaos/meson.build b/mlibc-workdir/sysdeps/echidnaos/meson.build
new file mode 100644
index 0000000..be98069
--- /dev/null
+++ b/mlibc-workdir/sysdeps/echidnaos/meson.build
@@ -0,0 +1,47 @@
+libc_sources += files(
+	'generic/entry.cpp',
+	'generic/generic.cpp',
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/abi.h',
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		subdir: 'abi-bits'
+	)
+	install_headers(
+		'include/sys_api.h',
+	)
+endif
+
+if not headers_only
+	custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-i386/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
